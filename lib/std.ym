def printf(format U8 ptr) I32 = __primitive__(libc) __varargs__
def puts(string U8 ptr) I32 = __primitive__(libc)
def putchar(char I32) I32 = __primitive__(libc)

def size{T}(arr T[]) I64 = __primitive__(slice_size)
def unsafe_ptr{T}(arr T[]) T ptr = __primitive__(slice_ptr)
def []{T}(ptr T ptr, offset I64) T mut = __primitive__(get_at)
def []={T}(ptr T ptr, offset I64, val T) T = __primitive__(set_at)
def dup_internal{T}(arr T[], extra I64) T[] = __primitive__(slice_dup)

# TODO: most of these should be templated
def +(a I32, b I32) I32 = __primitive__(ib_add)
def +(a I64, b I64) I64 = __primitive__(ib_add)
def +(a U8, b U8) U8 = __primitive__(ib_add)
def -(a I32, b I32) I32 = __primitive__(ib_sub)
def -(a I64, b I64) I64 = __primitive__(ib_sub)
def -(a I32) I32 = 0 - a
def -(a U8, b U8) U8 = __primitive__(ib_sub)
def %(a I32, b I32) I32 = __primitive__(ib_srem)
def *(a I32, b I32) I32 = __primitive__(ib_mul)
def //(a I32, b I32) I32 = __primitive__(ib_sdiv)
def ==(a I64, b I64) Bool = __primitive__(ib_icmp_eq)
def ==(a I32, b I32) Bool = __primitive__(ib_icmp_eq)
def ==(a U8, b U8) Bool = __primitive__(ib_icmp_eq)
def !=(a U8, b U8) Bool = __primitive__(ib_icmp_ne)
def >(a I32, b I32) Bool = __primitive__(ib_icmp_sgt)
def >(a I64, b I64) Bool = __primitive__(ib_icmp_sgt)
def <(a I32, b I32) Bool = __primitive__(ib_icmp_slt)
def <(a I64, b I64) Bool = __primitive__(ib_icmp_slt)
def !(a Bool) Bool
  if a
    return false
  else
    return true
  end
end

def []{T}(slice T[] mut, offset I64) T mut = slice.unsafe_ptr[offset]
def []{T}(slice T[], offset I64) T = slice.unsafe_ptr[offset]
def []={T}(slice T[] mut, offset I64, val T) T
  slice.unsafe_ptr[offset] = val
  return val
end

def copy{T}(source T ptr, dest T ptr, amount I64)
  let count I64 = amount
  while count > 0
    count = count - 1
    dest[count] = source[count]
  end
end

def dup{T}(arr T[], extra I64) T[]
  let dup_t T[] = arr.dup_internal(extra)
  copy(arr.unsafe_ptr, dup_t.unsafe_ptr, arr.size)
  return dup_t
end

def dup_append{T}(arr T[], last T) T[]
  let dup_t T[] = arr.dup_internal(1)
  copy(arr.unsafe_ptr, dup_t.unsafe_ptr, arr.size)
  dup_t[arr.size] = last
  return dup_t
end

# TODO: type inference should be able to cast I32 to U8, having determined U8 as the replacement for T
def c_str(str U8[]) U8[] = str.dup_append(?\0)

def c_len(ptr U8 ptr) I64
  let terminated Bool = false
  # TODO: the left and right sides of this declaration are attached, but should be able to merge into the bigger int type, investigate why this isn't happening
  let idx I64 = I64(0)
  while !terminated
    let chr U8 = ptr[idx]
    if chr == ?\0
      terminated = true
    else
      idx = idx + 1
    end
  end
  return idx
end
